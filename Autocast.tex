% This is based on the LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.4 for LaTeX2e as of 16. April 2010
%
% See http://www.springer.com/computer/lncs/lncs+authors?SGWID=0-40209-0-0-0
% for the full guidelines.
%



\documentclass{llncs}
\usepackage{graphicx}
\hyphenation{op-tical net-works semi-conduc-tor}
\usepackage{hyperref}
\usepackage{courier}
\usepackage{color}
\usepackage[scaled]{helvet}
\usepackage{listings}
%\newcounter{codecounter}[subsection]

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\lstset{numberbychapter=false}

\lstdefinestyle{Cstyle}{
    language=C,
    linewidth=12cm,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    backgroundcolor=\color{backcolour},
    commentstyle=\itshape\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{purple},
    basicstyle=\footnotesize\ttfamily,
    numbers=left,
    xleftmargin=\parindent,
    framexleftmargin=\parindent,
    numbersep=4pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    firstnumber=1,
    tabsize=1
}
\lstdefinestyle{Xstyle}{
    language=C,
    linewidth=12cm,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    backgroundcolor=\color{backcolour},
    commentstyle=\itshape\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{purple},
    basicstyle=\footnotesize\ttfamily,
    %numbers=left,
    xleftmargin=\parindent,
    framexleftmargin=\parindent,
    %numbersep=4pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    %firstnumber=1,
    tabsize=1
}



% define tabs for otabbing region
\newcommand{\otabs}{\hspace*{8mm}\=\hspace*{8mm}\=\hspace{8mm}\=}
% otabbing for creating examples
\newenvironment{otabbing}[1][\otabs]
	{\begin{tabbing}#1\kill}
	{\end{tabbing}}
% typewriter font bold, like textbt, but with the C '#' before pragma
\newcommand{\textct}[1]{\texttt{\textbf{\#\detokenize{#1}}}}
% typewriter font bold after detokenizing, so we can use underscores
\newcommand{\textbt}[1]{\texttt{\textbf{\detokenize{#1}}}}
% typewriter font bold without detokenizing, so we can use \{ and \}
\newcommand{\textat}[1]{\texttt{\textbf{#1}}}

\begin{document}

\title{Automatic Testing of OpenACC Applications}
%
\titlerunning{Automatic Testing of OpenACC}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{Khalid Ahmad\inst{1} \and Michael Wolfe\inst{2}}
%
\authorrunning{Khalid Ahmad et al.} % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
\tocauthor{Khalid Ahmad, Michael Wolfe}
%
\institute{University of Utah,
Salt Lake City, UT, USA\\
\email{Khalid@cs.utah.edu}
\and
NVIDIA/PGI, Beaverton, OR, USA\\ \email{mwolfe@nvidia.com}}

\maketitle              % typeset the title of the contribution

\begin{abstract}
CAST (Compiler-Assisted Software Testing) is a feature in our compiler and runtime to help users automate testing high performance numerical programs.
CAST normally works by running a known working version of a program and saving intermediate results to a reference file, then running a test version of a program and comparing the intermediate results against the reference file.
Here, we describe the special case of using CAST on OpenACC programs running on a GPU.
Instead of saving and comparing against a saved reference file, the compiler generates code to run each compute region on both the host CPU and the GPU.
The values computed on the host and GPU are then compared, using OpenACC data directives and clauses to decide what data to compare.
\keywords{Program testing}
\end{abstract}
%



\input{AutoIntro}
\input{AutoProblem}
\input{AutoUsage}
\input{AutoImpl}
\input{AutoExp}
\input{AutoConclude}
%


%\section{Obstacles for Unit Tests in HPC}

%\section {What Problems are addressed}
%\subsection{comparing results between a known good version (golden) and a version being tested}
%  - deciding what values to save / compare
%  - deciding when to save / compare values
%  - deciding how to do the compare, esp. for floating point
%\subsection{Usage Scenarios}
%  - user driven, save golden values to a file, compare test version against those
%    using API calls or directives
%    user decides what values to save/compare, when to compare
%  - automatic online compare, compare CPU vs GPU computations
%    can either compare after each kernel launch, or
%    compare all values present on device against golden host values

%\section{Implementation Details}
%   compare options - tolerance, IEEE comparisons
%   where in the runtime it is implemented (?)
%   challenges: Fortran vs C, gcc-specific header file functionality
%   saving a golden file, file block headers to compare execution sequence

%\section{Experimentation}
%   cost overhead of compare
%   cost overhead of autocompare
%   what kinds of differences we find
%
%\section{Other Uses of a Compare Feature}
%   compare different algorithms
%   compare compiler optimizations
%   compare different hosts

\bibliographystyle{IEEEtran}
\bibliography{main}



\end{document}
