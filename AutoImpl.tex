\section{Autocompare Implementation}

The implementation of OpenACC autocompare is split between our OpenACC compiler and the OpenACC runtime.
It depends a great deal on the \emph{present table}\cite{wolfe.ashes.17} maintained by the OpenACC runtime.

Most of the compiler work was to enable redundant execution of compute constructs on both the host and device.
Our implementation already had the capability of generating code for both host and device and selecting which to execute.
We modified that capability so that instead of selecting whether to launch a device kernel or run the host code, it would do both.
Currently, the CPU code runs sequentially.

The compiler already inserted runtime calls for any explicit or implicit data clauses.
In redundant execution mode, these runtime calls follow both the device kernel launch and the host redundant execution.
That allowed us to repurpose those runtime calls to do the data compare.
The compiler sets two flags in the runtime call, one to tell the runtime that it is in redundant mode and should not actually update host values, and a second to tell the runtime to compare values.

By default, our initial implementation will compare values that appear in a \emph{copy} or \emph{copyout} data clauses (explicitly or implicitly), or an \emph{update host} directive.
We have also implemented two runtime routines that will compare host and device values for specific variables or arrays, or for all data present on the device.
We have an option to disable the automatic comparisons, for when the user adds those runtime routine calls.

The runtime routines use the \emph{present table} to simplify the interface to the user.
Our implementation of the \emph{present table} saves the variable or array name, its host address, the corresponding device address, the data type, and the length.
With this information saved implicitly, the user can compare a single variable or array by just passing the address of that variable or array to the runtime routine \textbt{acc_compare}.
The runtime routine will then:
\begin{itemize}
\item look in the \emph{present table} for the device address, data type, and length;
\item allocate a block of memory for that data;
\item download the data from device memory; and
\item compare the host values to the downloaded data;
\end{itemize}
The user can compare all data on the device by calling the runtime routine \textbt{acc_compare_all} with no arguments at all.
That routine will traverse the entire present table and essentially call \textbt{acc_compare} for each variable or array in the table.

The user can set various options using the \textbt{PGI_COMPARE} environment variable.
The user can set an \emph{absolute tolerance} or \emph{relative tolerance} for floating point comparisons.
The user can select report options, such as to only report the first $n$ differences, or to skip the first $n$ differences.
Finally, the user can select the action to take when the report limit is exceeded, to stop execution, continue execution, or to patch the bad results and then continue.
In our implementation, patching the values means updating the device locations with the host values.
The \textbt{PGI_COMPARE} environment variable contains a comma-separated list of options; set Table~\ref{env} for details.
\begin{table}
\begin{center}
\begin{tabular}{ll}
\hline
option & Description \\
% \multicolumn{1}{l}{\rule{0pt}{12pt} \textbt{export PGICOMPARE=option[,option]}
% }&\multicolumn{1}{l}{  Description }\\[2pt]
\hline
\textbt{abs=}\textit{r} & Use $10^{-r}$ as an absolute tolerance \\
\textbt{rel=}\textit{r} & Use $10^{-r}$ as a relative tolerance \\
\textbt{report=}\textit{n} & Report first \textit{n} differences \\
\textbt{skip=}\textit{n}    & Skip the first \textit{n} differences \\
\textbt{patch}   &   Patch erroneous values with correct values \\
\textbt{stop}   &   Stop at after \textbt{report=} differences \\
\hline
\end{tabular}
\end{center}
\caption{Options that can appear in the \textbt{PGI_COMPARE} environment variable.}
\label{env}
\end{table}
